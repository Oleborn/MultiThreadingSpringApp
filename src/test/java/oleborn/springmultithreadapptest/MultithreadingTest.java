package oleborn.springmultithreadapptest;


import lombok.extern.slf4j.Slf4j;
import oleborn.springmultithreadapptest.exception.AccountNotFountByIDException;
import oleborn.springmultithreadapptest.exception.AccountNotFountByNumberException;
import oleborn.springmultithreadapptest.exception.BalanceException;
import oleborn.springmultithreadapptest.model.Account;
import oleborn.springmultithreadapptest.service.AccountService;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

import static org.junit.jupiter.api.Assertions.*;

@Slf4j
@SpringBootTest
public class MultithreadingTest {

    @Autowired
    private AccountService accountService;

    @BeforeEach
    public void setUp() {
        // Создаем три тестовых аккаунта
        accountService.createAccount(
                Account.builder()
                        .accountNumber("ACC1")
                        .balance(BigDecimal.valueOf(1000))
                        .ownerName("Alice")
                        .version(0)
                        .build()
        );
        accountService.createAccount(
                Account.builder()
                        .accountNumber("ACC2")
                        .balance(BigDecimal.valueOf(1000))
                        .ownerName("Bob")
                        .version(0)
                        .build()
        );
        accountService.createAccount(
                Account.builder()
                        .accountNumber("ACC3")
                        .balance(BigDecimal.valueOf(0))
                        .ownerName("Charlie")
                        .version(0)
                        .build()
        );
    }

    @AfterEach
    public void tearDown() {
        //удаляем созданные аккаунты
        accountService.deleteAccount(accountService.getAccountByNumber("ACC1").getId());
        accountService.deleteAccount(accountService.getAccountByNumber("ACC2").getId());
        accountService.deleteAccount(accountService.getAccountByNumber("ACC3").getId());
    }


    /**
     * <h2>Этот тест демонстрирует основы работы с потоками в Java, включая создание потоков, их запуск,
     * синхронизацию с использованием методов `join()`, и работу с прерываниями потоков с помощью `interrupt()`.</h2>
     *
     * <h3>Цели теста:</h3>
     * <ol>
     *     <li>Научиться создавать и управлять потоками в Java.</li>
     *     <li>Понять разницу между конкурентным и последовательным выполнением задач.</li>
     *     <li>Изучить методы `start()`, `join()`, `interrupt()` и их влияние на выполнение потоков.</li>
     *     <li>Познакомиться с потокобезопасными классами, такими как `AtomicInteger`.</li>
     *     <li>Осознать важность корректного управления потоками для предотвращения ошибок в многопоточном окружении.</li>
     * </ol>
     *
     * <h3>Описание:</h3>
     * <ol>
     *     <li>Для безопасного увеличения общего счетчика используется класс `AtomicInteger`, который обеспечивает потокобезопасную операцию
     *     увеличения значения с помощью метода `incrementAndGet()`.</li>
     *     <li>Для демонстрации многозадачности создаются два потока, каждый из которых выполняет задачу увеличения счетчика на 100.</li>
     *     <li>Метод `start()` запускает каждый поток параллельно, и каждый поток увеличивает счетчик до 100, что в сумме дает 200.</li>
     *     <li>Метод `join()` используется, чтобы основной поток дождался завершения обоих потоков до проверки результата, иначе тест может завершиться
     *     раньше, чем потоки успеют выполнить свою задачу.</li>
     *     <li>Метод `assertEquals()` используется для проверки, что счетчик действительно достиг 200, что подтверждает правильную работу потоков
     *     и предотвращение гонки потоков (Race Condition) благодаря использованию `AtomicInteger`.</li>
     * </ol>
     *
     * <h3>Демонстрация работы с прерываниями:</h3>
     * <ol>
     *     <li>Создается еще один поток, который засыпает на 5 секунд с помощью метода `Thread.sleep(5000)`.</li>
     *     <li>Затем вызывается метод `interrupt()`, чтобы прервать выполнение этого потока. Это вызывает исключение `InterruptedException`,
     *     которое обрабатывается в блоке `catch`.</li>
     *     <li>Метод `join()` используется для синхронизации, чтобы основной поток дождался завершения потока с прерыванием.</li>
     * </ol>
     *
     * <h3>Ключевые моменты:</h3>
     * <ul>
     *     <li>Использование `AtomicInteger` предотвращает Race Condition, обеспечивая корректное выполнение операций в многопоточном окружении.</li>
     *     <li>Метод `start()` запускает новый поток, в то время как вызов `run()` выполняет задачу в текущем потоке, что является важным различием.</li>
     *     <li>Метод `join()` позволяет основному потоку ожидать завершения других потоков, предотвращая преждевременную завершение теста.</li>
     *     <li>Метод `interrupt()` позволяет прервать выполнение потока в процессе его работы, что полезно для управления состоянием потока и обработки ошибок.</li>
     * </ul>
     */
    @Test
    public void testThreadBasics() throws InterruptedException {
        /*

        AtomicInteger — это потокобезопасный класс, который позволяет безопасно увеличивать значение переменной в многопоточном окружении.
        Операция incrementAndGet() выполняется атомарно, то есть она гарантированно выполняется полностью без вмешательства других потоков.
         */
        AtomicInteger counter = new AtomicInteger();

        /*
        Thread — класс, который позволяет создавать и управлять потоками.
        В обоих потоках используется Runnable (лямбда-выражение), выполняющее одинаковую задачу: увеличение общего счетчика на 100 единиц.
        Параллельное выполнение: Оба потока работают одновременно, увеличивая общий счетчик до 200.
         */
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 100; i++) {
                counter.incrementAndGet(); // Увеличиваем счетчик
            }
        });

        // Создаем второй поток с тем же функционалом
        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 100; i++) {
                counter.incrementAndGet();
            }
        });

        /*
        start(): Начинает выполнение потока. Поток начинает выполнение с метода run(), который был передан в конструктор.
        Важно: Если вы вызовете run() напрямую, задача выполнится в текущем потоке, а не в новом.

        Разница между start() и run():
        start() создаёт новый поток.
        run() выполняет задачу в текущем потоке, без создания нового.
         */
        thread1.start(); // Запускаем первый поток
        thread2.start(); // Запускаем второй поток

        /*
        join(): Основной поток (в котором выполняется тест) ожидает завершения потоков thread1 и thread2.
        Без join() тест мог бы завершиться до завершения потоков, и проверка на 200 могла бы не пройти.
         */
        thread1.join(); // Ожидаем завершения первого потока
        thread2.join(); // Ожидаем завершения второго потока

        /*
        assertEquals: Убеждаемся, что общий счетчик достиг значения 200.
        Если потоки не завершились корректно или AtomicInteger не использовался, результат мог бы быть меньше 200 (из-за Race Condition).
        Потокобезопасные структуры данных:
        В данном случае использование AtomicInteger предотвращает Race Condition.
        Без него несколько потоков могли бы одновременно читать и изменять значение, что привело бы к неверному результату.
         */
        assertEquals(200, counter.get(), "Счетчик должен достигнуть 200, после завершения обоих потоков");

        /*
        Создание и запуск еще одного потока
        Этот поток выполняет задачу, которая вызывает Thread.sleep(5000), то есть засыпает на 5 секунд.
        sleep может быть прерван вызовом interrupt.
         */
        Thread thread = new Thread(() -> {
            try {
                Thread.sleep(5000); // Поток засыпает на 5 секунд
            } catch (InterruptedException e) {
                System.out.println("Thread was interrupted"); // Прерывание вызывает исключение
            }
        });

        thread.start(); // Запускаем поток

        /*
        interrupt(): Посылает сигнал потоку, чтобы прервать его выполнение.
        Если поток в состоянии ожидания или сна (например, вызван метод sleep), он пробуждается с исключением InterruptedException.
        Это позволяет безопасно завершить поток или перенаправить его логику.
         */
        thread.interrupt(); // Прерываем поток
        thread.join(); // Используем join() для синхронизации и ожидания завершения потока.
    }

    /**
     * <h4>Тест демонстрирует использование синхронизации в многопоточном окружении для предотвращения гонки потоков (Race Condition)
     * и корректного обновления общих ресурсов, таких как балансы аккаунтов.</h4>
     *
     * <h5>Цели теста:</h5>
     * <ol>
     *     <li>Изучить базовую синхронизацию с использованием ключевого слова `synchronized`.</li>
     *     <li>Убедиться, что потоки могут безопасно работать с общими ресурсами (например, балансы аккаунтов) при должной синхронизации.</li>
     *     <li>Понять, как синхронизация защищает от одновременного изменения общих данных несколькими потоками.</li>
     *     <li>Оценить, как высокоуровневые утилиты, такие как `ExecutorService`, помогают управлять многозадачностью в многопоточных приложениях.</li>
     * </ol>
     *
     * <h3>Алгоритм:</h3>
     * <ol>
     *     <li>Создается пул потоков с двумя потоками с помощью `Executors.newFixedThreadPool(2)`. Это гарантирует, что не более двух потоков
     *     будут одновременно выполнять задачи.</li>
     *     <li>Определяется задача типа `Runnable`, которая выполняет операцию перевода средств между двумя аккаунтами (например, с `ACC1` на `ACC2`).</li>
     *     <li>Для защиты от гонки потоков используется ключевое слово `synchronized`, которое блокирует доступ к общим ресурсам (в данном случае — к объекту `accountService`)
     *     во время выполнения перевода, гарантируя, что только один поток одновременно изменяет баланс на одном аккаунте.</li>
     *     <li>Проверяется состояние баланса аккаунтов до и после выполнения задач, чтобы убедиться, что синхронизация предотвращает некорректное обновление данных.</li>
     *     <li>Два потока отправляются на выполнение в пул потоков с помощью `executor.submit(task)`. Каждый поток выполняет задачу перевода средств.</li>
     *     <li>После выполнения задач пул потоков завершается вызовом `shutdown()`, и основная программа ожидает завершения всех задач с помощью `awaitTermination()`.</li>
     * </ol>
     *
     * <h3>Описание проблемы без синхронизации:</h3>
     * <p>Без синхронизации два потока могут одновременно считывать баланс одного и того же аккаунта и одновременно пытаться его изменить.
     * Например, оба потока могут прочитать баланс 1000 для `ACC1`, затем попытаться вычесть по 100 единиц, что приведет к неправильному результату
     * (оба потока запишут баланс 900 вместо 800).</p>
     *
     * <h3>Тестирование:</h3>
     * <ol>
     *     <li>После выполнения двух задач проверяется, что баланс `ACC1` уменьшился на 200 (по 100 за каждую задачу), а баланс `ACC2` увеличился на 200.</li>
     *     <li>Ожидаемые результаты:
     *         <ul>
     *             <li>Баланс `ACC1` должен быть 800 (1000 - 200).</li>
     *             <li>Баланс `ACC2` должен быть 1200 (1000 + 200).</li>
     *         </ul>
     *     </li>
     *     <li>Если синхронизация была бы удалена, результаты могли бы быть некорректными из-за гонки потоков (Race Condition), где оба потока обновляют баланс на 900 вместо 800.</li>
     * </ol>
     */
    @Test
    public void testSynchronization() throws InterruptedException {

        /*
        Создаётся пул из 2 потоков.
        Пул потоков управляет потоками и их жизненным циклом, позволяя выполнять задачи параллельно.
        Использование FixedThreadPool гарантирует, что не более двух потоков будут одновременно выполнять задачи.
         */
        ExecutorService executor = Executors.newFixedThreadPool(2); // Пул из 2 потоков

        /*
        Runnable — это функциональный интерфейс в Java, который представляет задачу, которую можно выполнить в отдельном потоке.
        Задача (task):
        Переводит 100 единиц с account1 на account2.
        synchronized (accountService):
        Блокирует доступ к объекту accountService. Это означает, что пока один поток выполняет эту задачу, другой поток не сможет войти в этот блок кода.
        Защищает от Race Condition, обеспечивая последовательное выполнение операций перевода.

        Почему нужна синхронизация?
        Без неё оба потока могли бы одновременно изменить баланс аккаунтов, что привело бы к несогласованным данным.
        Например, оба потока могли бы прочитать баланс 1000 для account1 до того, как он обновится, что привело бы к неправильному результату.
         */
        Runnable task = () -> {
            synchronized (accountService) { // Блокируем доступ к accountService для защиты от Race Condition
                try {
                    accountService.transfer(
                            "ACC1",
                            "ACC2",
                            BigDecimal.valueOf(100)
                    );
                } catch (Exception e) {
                    e.printStackTrace(); // Логируем ошибки для анализа
                }
            }
        };
        /*
        Когда мы убираем синхронизацию, оба потока выполняются параллельно. Оба потока могут в один и тот же момент
        времени читать баланс одного и того же аккаунта, делая вывод, что его баланс равен 1000. Затем оба потока
        пытаются вычесть по 100 из этого баланса, и в результате оба потока обновляют баланс как если бы второй поток
        не изменил баланс первым потоком.

        Первый поток: Считывает баланс 1000, уменьшает его на 100, пытаясь записать 900.
        Второй поток: Считывает баланс 1000 (так как первый поток еще не записал изменения), уменьшает его
        на 100, пытаясь записать 900.
        В результате оба потока записывают 900 вместо корректных значений. Т.е. оба потока считают баланс
        старым (1000), и обновляют его с ошибкой.

        В базе данных после выполнения двух задач, оба потока обновляют баланс как 900, несмотря на то, что каждый
        поток должен был уменьшить баланс на 100, а не на 200.
        Запросы update account set balance=? where id=? and version=? используют механизм оптимистичной блокировки,
        чтобы избежать изменения записей другим потоком в момент обновления. Однако, из-за race condition оба потока
        проходят проверку версии (версия не изменяется из-за синхронного обновления) и пытаются одновременно обновить
        записи.
         */

        /*
        Проверим состояние балансов аккаунтов до выполнения операций (тут для обучения можно убрать synchronized)
         */
        System.out.println("Баланс первого аккаунта до выполнения операций: " + accountService.getBalance("ACC1"));
        System.out.println("Баланс второго аккаунта до выполнения операций: " + accountService.getBalance("ACC2"));

        /*
        Две задачи отправляются в пул потоков.
        Поскольку задачи выполняются параллельно, без синхронизации результаты могли бы быть некорректными.
         */
        executor.submit(task); // Запускаем задачу в пуле потоков
        executor.submit(task); // Запускаем вторую задачу

        /*
        shutdown():
        Запрещает добавление новых задач в пул.
        Пул завершает выполнение уже отправленных задач.
        awaitTermination:
        Ожидает завершения всех задач в пуле.
        Если задачи не завершатся за 5 секунд, тест завершится с исключением TimeoutException.
         */
        executor.shutdown(); // Останавливаем пул, после выполнения текущих задач
        boolean b = executor.awaitTermination(5, TimeUnit.SECONDS);// Ждем завершения всех задач

        /*
        Проверим состояние балансов аккаунтов после выполнения операций
         */
        System.out.println("Баланс первого аккаунта после выполнения операций: " + accountService.getBalance("ACC1"));
        System.out.println("Баланс второго аккаунта после выполнения операций: " + accountService.getBalance("ACC2"));

        /*
        После выполнения двух задач ожидается:
        Что задачи завершатся за 5 секунд.
        Баланс account1 уменьшится на 200 (два перевода по 100).
        Баланс account2 увеличится на 200.

        Почему результат именно такой?
        Каждая задача переводит 100 единиц.
        Так как задачи синхронизированы, баланс обновляется последовательно, что гарантирует корректный результат.
         */
        assertTrue(b);
        assertEquals(BigDecimal.valueOf(800.00).setScale(2, RoundingMode.HALF_UP),
                accountService.getBalance("ACC1"));
        assertEquals(BigDecimal.valueOf(1200.00).setScale(2, RoundingMode.HALF_UP),
                accountService.getBalance("ACC2"));

        /*
        Если убрать synchronized, результаты могут быть непредсказуемыми:
        Оба потока одновременно прочитают баланс account1 = 1000.
        Каждый поток снимет 100, посчитав, что баланс после первой операции будет 900.
        Итоговый баланс может оказаться 900 вместо ожидаемых 800.
        Такой результат возникает из-за Race Condition, когда несколько потоков одновременно работают с одними и теми же данными без координации.
         */
    }

    /**
     * <h4>Тест демонстрирует использование класса `ExecutorService` для управления пулом потоков и выполнения асинхронных задач.</h4>
     *
     * <p>Цели теста:</p>
     * <ol>
     *     <li>Продемонстрировать использование пула потоков для управления многозадачностью и эффективного выполнения задач.</li>
     *     <li>Показать работу с интерфейсом `Callable` и классом `Future` для получения результатов асинхронных операций.</li>
     * </ol>
     *
     * <h3>Основные компоненты:</h3>
     * <ul>
     *     <li><b>ExecutorService:</b> Интерфейс для управления пулами потоков. В данном тесте используется метод
     *     `Executors.newFixedThreadPool(2)`, который создает пул с двумя потоками для одновременного выполнения задач.</li>
     *     <li><b>Callable:</b> Функциональный интерфейс, аналогичный `Runnable`, но с возможностью возвращать результат
     *     или выбрасывать исключение. В тесте используется для определения задач, которые будут выполняться в пуле потоков.</li>
     *     <li><b>Future:</b> Интерфейс, который представляет результат асинхронной операции. В тесте используется для получения
     *     результатов выполнения задач, а также для обработки возможных исключений.</li>
     * </ul>
     *
     * <h3>Алгоритм:</h3>
     * <ol>
     *     <li>Создается пул потоков с двумя потоками с помощью `Executors.newFixedThreadPool(2)`.</li>
     *     <li>Определяются две задачи типа `Callable`, которые имитируют длительные операции с помощью `Thread.sleep()`.
     *     Каждая задача возвращает строковый результат после завершения.</li>
     *     <li>Задачи отправляются на выполнение в пул потоков с помощью метода `executor.submit()`, который возвращает объект
     *     типа `Future` для каждой задачи. Эти объекты используются для получения результатов.</li>
     *     <li>Методы `future1.get()` и `future2.get()` вызываются для блокировки текущего потока до тех пор, пока задачи не
     *     завершатся. После завершения задач проверяется, что результаты выполнения соответствуют ожидаемым.</li>
     *     <li>После выполнения всех задач вызывается метод `executor.shutdown()`, чтобы корректно завершить работу пула потоков
     *     и освободить ресурсы.</li>
     * </ol>
     *
     * <h3>Тестирование:</h3>
     * <p>После выполнения теста проверяется, что результаты выполнения задач совпадают с ожидаемыми:
     * - Для первой задачи (task1) ожидается результат "Task 1 completed".
     * - Для второй задачи (task2) ожидается результат "Task 2 completed".
     * Это подтверждает правильную работу пула потоков и корректность выполнения асинхронных операций.</p>
     */

    @Test
    public void testExecutorService() throws ExecutionException, InterruptedException {

        /*
        Создаем пул потоков с помощью Executors.newFixedThreadPool(2).
        Это создает пул из двух потоков, которые могут одновременно выполнять задачи.
        Важно отметить, что пул потоков управляет созданием и завершением потоков, а также их жизненным циклом.
        Если в пуле потоков не хватает потоков для выполнения всех задач, то задачи будут ставиться в очередь и
        ожидать своей очереди на выполнение.
         */
        ExecutorService executor = Executors.newFixedThreadPool(2); // Пул из 2 потоков

        /*
         Callable — это функциональный интерфейс, аналогичный Runnable, но с тем отличием, что Callable
         может возвращать результат или бросить исключение.
         */

        Callable<String> task1 = () -> {
            Thread.sleep(1000); // Имитируем длительную операцию
            return "Task 1 completed"; // Возвращаем результат
        };

        // Задача 2
        Callable<String> task2 = () -> {
            Thread.sleep(2000);
            return "Task 2 completed";
        };

        /*
        Future — это интерфейс, который представляет результат асинхронной операции.
        Он позволяет нам получить результат выполнения задачи (если она завершилась успешно)
        или обработать исключения, если они возникли.

         future1 = executor.submit(task1) запускает задачу task1 в одном из потоков пула и возвращает объект
         типа Future<String>, который будет использоваться для получения результата выполнения задачи.
         */

        Future<String> future1 = executor.submit(task1); // Получаем Future для задачи 1
        Future<String> future2 = executor.submit(task2); // Получаем Future для задачи 2


        /*
        future1.get() и future2.get() — это блокирующие вызовы, которые заставляют основной поток ожидать
        завершения соответствующих задач
        Метод get() блокирует текущий поток до тех пор, пока задача не завершится, и возвращает результат выполнения задачи.

        После того как задачи завершатся, мы проверяем с помощью assertEquals, что результат выполнения задачи совпадает с ожидаемым:
        Для future1 ожидаем результат "Task 1 completed".
        Для future2 ожидаем результат "Task 2 completed".
        Если результат не совпадает с ожидаемым, будет выброшено исключение AssertionError, и тест не пройдет.
         */
        assertEquals("Task 1 completed", future1.get()); // Ожидаем завершения задачи 1
        assertEquals("Task 2 completed", future2.get()); // Ожидаем завершения задачи 2

        /*
        Метод shutdown() завершает работу пула потоков.
        После вызова этого метода пул не будет принимать новые задачи, но он продолжит выполнять уже
        запущенные задачи, пока не завершит их. Важно вызвать shutdown() после того, как все задачи завершены,
        чтобы корректно завершить работу пула и освободить ресурсы.
         */
        executor.shutdown(); // Завершаем работу пула потоков
    }

    /**
     * <h4>Тест демонстрирует использование классов `CountDownLatch` и `Semaphore` из пакета `java.util.concurrent`
     * для управления многопоточными операциями.</h4>
     *
     * <p>Цели теста:</p>
     * <ol>
     *     <li>Продемонстрировать, как `CountDownLatch` позволяет синхронизировать потоки, ожидая выполнения
     *     определенного количества задач.</li>
     *     <li>Показать использование `Semaphore` для ограничения доступа к ресурсам с помощью разрешений (permits).</li>
     * </ol>
     *
     * <p>В данном тесте:</p>
     * <ul>
     *     <li>Используется `CountDownLatch` для ожидания завершения трех задач. Это позволяет синхронизировать
     *     завершение работы всех потоков, прежде чем продолжить выполнение теста.</li>
     *     <li>Используется `Semaphore` для ограничения доступа к ресурсу, что гарантирует, что не более трех потоков
     *     одновременно выполняют задачи перевода средств между счетами.</li>
     * </ul>
     *
     * <h3>Описание работы:</h3>
     * <p>В ходе выполнения теста создаются три асинхронные задачи перевода средств между тремя счетами. Каждая задача
     * выполняется в отдельном потоке. Потоки ожидают получения разрешений через `Semaphore` перед выполнением своих
     * задач. После завершения каждой задачи уменьшается счетчик в `CountDownLatch`, что позволяет главному потоку
     * дождаться завершения всех операций перед продолжением.</p>
     *
     * <h3>Основные компоненты:</h3>
     * <ul>
     *     <li><b>CountDownLatch:</b> Синхронизатор, который ожидает, пока счетчик не станет равным 0. В данном случае
     *     главный поток блокируется до тех пор, пока все три асинхронные задачи не завершатся, после чего продолжает
     *     выполнение теста.</li>
     *     <li><b>Semaphore:</b> Класс для управления доступом к ограниченному ресурсу с использованием разрешений.
     *     В тесте семафор ограничивает количество потоков, которые могут одновременно выполнять переводы.</li>
     * </ul>
     *
     * <h3>Алгоритм:</h3>
     * <ol>
     *     <li>Создаются три задачи, каждая из которых выполняет перевод между двумя счетами. Каждая задача блокирует
     *     доступ к ресурсу с помощью `Semaphore` и запускается в отдельном потоке.</li>
     *     <li>После выполнения каждой задачи освобождается разрешение, а счетчик в `CountDownLatch` уменьшается.</li>
     *     <li>Главный поток ожидает, пока все три задачи завершат выполнение (счетчик `CountDownLatch` станет равен 0).</li>
     *     <li>После завершения всех задач главный поток проверяет корректность выполнения операций, проверяя балансы
     *     на счетах.</li>
     * </ol>
     *
     * <h3>Тестирование:</h3>
     * <p>После выполнения теста проверяется, что баланс всех счетов обновлен правильно:
     * - Баланс счета "ACC1" должен быть равен 1000.00.
     * - Баланс счета "ACC2" должен быть равен 1000.00.
     * - Баланс счета "ACC3" должен быть равен 0.00.
     * Это подтверждает, что средства были корректно переведены между счетами, и операции были синхронизированы
     * с использованием `CountDownLatch` и `Semaphore`.</p>
     */
    /*
    Проблема без блокировок
    Если потоки работают одновременно без контроля:

    Поток 1 считывает баланс ACC1 (1000) и ACC2 (1000).
    Поток 2 считывает баланс ACC2 (1000) и ACC3 (1000).
    Поток 3 считывает баланс ACC3 (1000) и ACC1 (1000).
    Все потоки начинают обновлять балансы одновременно, но в какой-то момент данные могут перезаписаться, например:

    Поток 1 обновляет ACC2, но в этот момент Поток 2 тоже обновляет ACC2.
    В результате баланс ACC2 становится неверным.
    Решение: использование блокировок
    С блокировками мы решаем проблему, гарантируя, что только один поток может работать с каждым счетом одновременно.

    Как это работает

    Мы создаем блокировку (ReentrantLock) для каждого счета:
    Для ACC1 — своя блокировка.
    Для ACC2 — своя блокировка.
    Для ACC3 — своя блокировка.

    Теперь, перед началом операции, поток должен захватить блокировки для всех участвующих счетов:
    Поток 1 захватывает блокировки для ACC1 и ACC2.
    Другие потоки, которые хотят работать с этими счетами, должны ждать, пока блокировки не освободятся.
    Поток 2 ждет, потому что ACC2 уже заблокирован.
    Поток 3 работает с ACC3, потому что ACC3 не заблокирован.
    После завершения операции Поток 1 освобождает блокировки, и Поток 2 может начать свою работу.
     */
    @Test
    public void testConcurrentUtilities() throws InterruptedException {

        /*
        CountDownLatch — это синхронизатор, который позволяет потокам ожидать,
        пока счетчик не станет равным 0.
        В данном тесте CountDownLatch используется, чтобы гарантировать, что главный поток (в котором выполняется тест)
        не завершится раньше, чем завершатся все три асинхронные задачи перевода (task1, task2, task3).
        Создаем CountDownLatch с начальным значением 3. Это значение определяет,
        сколько раз нужно вызвать countDown() для того, чтобы await() прекратил блокировку.
         */
        CountDownLatch latch = new CountDownLatch(3);

        /*
        Создаем Semaphore с разрешением для 2 потоков одновременно.
        Это означает, что только два потока могут выполнять задачи, защищенные этим семафором, в определенный момент времени.
         */
        Semaphore semaphore = new Semaphore(3);

        /*
        Определяем задачи, которые использует Semaphore для контроля доступа.
        Поток запрашивает разрешение через acquire(), выполняет работу и освобождает разрешение через release().
         */

        // Асинхронные задачи перевода с использованием Semaphore
        Runnable task1 = () -> {
            try {
                // Получаем разрешение от семафора
                // Если разрешение недоступно, поток будет заблокирован, пока не освободится.
                semaphore.acquire();
                System.out.println("Task 1 running");
                // Выполняем асинхронный перевод через сервис
                accountService.transferAsync("ACC1", "ACC2", new BigDecimal("100"))
                        .whenComplete((result, ex) -> {
                            // Освобождаем разрешение, чтобы другие потоки могли получить доступ к ресурсу
                            semaphore.release();
                            // После успешного завершения задачи уменьшаем счетчик на 1
                            latch.countDown();
                        });
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        };

        Runnable task2 = () -> {
            try {
                // Получаем разрешение от семафора
                // Если разрешение недоступно, поток будет заблокирован, пока не освободится.
                semaphore.acquire();
                System.out.println("Task 2 running");
                // Выполняем асинхронный перевод через сервис
                accountService.transferAsync("ACC2", "ACC3", new BigDecimal("100"))
                        .whenComplete((result, ex) -> {
                            // Освобождаем разрешение, чтобы другие потоки могли получить доступ к ресурсу
                            semaphore.release();
                            // После успешного завершения задачи уменьшаем счетчик на 1
                            latch.countDown();
                        });
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        };

        Runnable task3 = () -> {
            try {
                // Получаем разрешение от семафора
                // Если разрешение недоступно, поток будет заблокирован, пока не освободится.
                semaphore.acquire();
                System.out.println("Task 3 running");
                // Выполняем асинхронный перевод через сервис
                accountService.transferAsync("ACC3", "ACC1", new BigDecimal("100"))
                        .whenComplete((result, ex) -> {
                            // Освобождаем разрешение, чтобы другие потоки могли получить доступ к ресурсу
                            semaphore.release();
                            // После успешного завершения задачи уменьшаем счетчик на 1
                            latch.countDown();
                        });
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        };


        // Запускаем три потока, каждый из которых выполняет задачу и уменьшает счетчик
        new Thread(task1).start(); // Запускаем первую задачу
        new Thread(task2).start(); // Запускаем вторую задачу
        new Thread(task3).start(); // Запускаем третью задачу

        /*
        Главный поток блокируется до тех пор, пока значение счетчика latch не станет 0.
        Это гарантирует, что все три потока завершат выполнение своих задач до продолжения работы.
         */
        latch.await();

        // Проверяем, что счетчик latch действительно равен 0
        // Метод getCount() возвращает текущее значение счетчика
        assertEquals(0, latch.getCount());

        // Убедимся, что средства списаны и зачислены корректно
        assertEquals(new BigDecimal("1000.00").setScale(2, RoundingMode.HALF_UP),
                accountService.getAccountByNumber("ACC1").getBalance());
        assertEquals(new BigDecimal("1000.00").setScale(2, RoundingMode.HALF_UP),
                accountService.getAccountByNumber("ACC2").getBalance());
        assertEquals(new BigDecimal("0.00").setScale(2, RoundingMode.HALF_UP),
                accountService.getAccountByNumber("ACC3").getBalance());
    }

    /**
     * <h4>Тест демонстрирует использование ключевого слова `volatile` в Java для обеспечения видимости изменений переменной
     * между потоками. Это пример простейшей реализации механизма управления состоянием потока.</h4>
     *
     * <h3>Цели:</h3>
     * <ul>
     *     <li>Продемонстрировать использование `volatile` для обеспечения согласованности состояния между потоками.</li>
     *     <li>Показать, как `volatile` предотвращает кэширование переменных в локальной памяти потоков.</li>
     *     <li>Объяснить, как правильно завершить поток, используя видимость переменной.</li>
     * </ul>
     *
     * <p>Этот тест использует ключевое слово `volatile` для контроля завершения выполнения потока. Поток выполняет бесконечный цикл,
     * который будет завершен при изменении значения переменной, помеченной как `volatile`.</p>
     *
     * <h3>Модель памяти Java (JMM):</h3>
     * <p>Без использования `volatile` переменная может быть кэширована в локальной памяти потока, что может привести к несогласованности
     * данных между потоками. Объявление переменной как `volatile` гарантирует, что все чтения и записи переменной происходят
     * из основной памяти и будут видны другим потокам. Также `volatile` предотвращает переупорядочивание операций записи и чтения
     * переменных в многопоточном контексте.</p>
     *
     * <h3>Примечания:</h3>
     * <ul>
     *     <li>Запрещает кэширование переменных, делая их доступными для всех потоков.</li>
     *     <li>Гарантирует, что изменения переменной, сделанные одним потоком, сразу становятся видимыми для других потоков.</li>
     *     <li>Предотвращает переупорядочивание операций чтения/записи переменных в многопоточном контексте.</li>
     * </ul>
     *
     * <h3>Ограничения:</h3>
     * <ul>
     *     <li>Не обеспечивает атомарности операций. Например, операции типа `x++` не являются безопасными в многопоточности, даже с `volatile`.</li>
     *     <li>Если требуется синхронизация нескольких операций, рекомендуется использовать `synchronized` или высокоуровневые механизмы,
     *     такие как `Lock`.</li>
     * </ul>
     */
    /*
    Модель памяти Java (JMM)
    Основная память (Main Memory): это область, в которой хранятся значения всех переменных, доступных потокам.
    Локальная память потока (Thread's Local Cache): каждый поток может иметь свою копию переменных, хранящуюся в
    кэше процессора или регистрах, чтобы ускорить доступ.

    Без использования volatile:
    Поток может читать и записывать значения переменной только в своём локальном кэше, что может привести к
    несогласованности данных между потоками.
    Например, один поток изменяет значение переменной, но другой поток продолжает использовать устаревшую копию
    из своего локального кэша.

    Когда переменная объявлена как volatile:

    Гарантия видимости:
    Все операции записи в переменную volatile непосредственно обновляют значение в основной памяти.
    Все операции чтения переменной извлекают её значение из основной памяти, а не из локального кэша.
    Это предотвращает ситуацию, когда изменения, сделанные одним потоком, не видны другим потокам.

    Запрет оптимизации:
    Компилятор и процессор не оптимизируют код, связанный с переменной volatile, таким образом, чтобы чтения
    или записи могли "исчезать" (например, быть переупорядоченными или кэшированными).

    Запрет переупорядочивания:
    volatile вводит барьер памяти (memory barrier).
    Это ограничение на порядок инструкций:
    Перед записью в volatile переменную гарантируется, что все предшествующие операции записи завершены и
    видны другим потокам.
    После чтения из volatile переменной гарантируется, что все последующие операции чтения/записи начинаются
    только после того, как чтение завершено.

    Ограничения volatile
    volatile не обеспечивает атомарности операций (например, x++ всё ещё небезопасно в многопоточности).
    Если требуется синхронизация нескольких связанных операций, лучше использовать synchronized или
    высокоуровневые механизмы, такие как Lock.
     */
    @Test
    public void testVolatile() throws InterruptedException {
        /*
         * Вложенный класс демонстрирует пример использования `volatile`.
         * Он содержит флаг состояния `running`, который может быть изменён одним потоком и проверен другим.
         */
        class VolatileExample {
            /*
             Переменная `running` используется для управления выполнением цикла в методе `run`.
             Ключевое слово volatile в Java предотвращает кэширование переменной в локальной памяти потока
             и гарантирует, что все чтения и записи этой переменной происходят из общей (основной) памяти.
             Это достигается за счёт реализации модели памяти Java (Java Memory Model, JMM).
             */

            //TODO изначально тест пишем без volatile
            private volatile boolean running = true; // Обеспечивает видимость изменений между потоками

            /*
             * Этот метод меняет значение `running` на `false`.
             * После этого рабочий поток, выполняющий цикл в методе `run`, завершится.
             */
            public void stop() {
                System.out.println("running изменяется на false");
                running = false; // Меняем значение

            }

            /*
             * Метод выполняет бесконечный цикл, пока `running` имеет значение `true`.
             * После изменения `running` на `false` метод завершает выполнение.
             * Благодаря `volatile` поток корректно завершает выполнение,
             * поскольку изменения переменной `running` немедленно видны.
             */
            public void run() {
                // Цикл будет выполняться до тех пор, пока переменная `running` равна true.
                while (running) {
                    // busy-wait
                }
                // Когда `running` становится false, выполнение выходит из цикла, и сообщение выводится в консоль.
                System.out.println("Поток остановлен.");
            }
        }

        // Создаём объект класса `VolatileExample` в основном потоке.
        VolatileExample example = new VolatileExample();

        // Создаём дополнительный поток, который запускает метод `run` объекта `example`.
        Thread thread = new Thread(example::run);
        // Запускаем поток. Он начинает выполнение метода `run`.
        thread.start();

        Thread.sleep(1000); // Ждём 1 секунду, чтобы дать потоку время начать выполнение и войти в цикл
        example.stop(); // Сигнализируем потоку завершить выполнение, изменяя значение `running` на `false`.

        // Ожидаем завершения потока. Метод `join` блокирует текущий поток (тестовый)
        // до тех пор, пока поток `thread` не завершит выполнение.
        thread.join();

        // Проверяем, что поток завершил выполнение, а переменная `running` имеет значение `false`.
        // Хотя `volatile` не гарантирует атомарности операций, оно обеспечивает видимость изменений между потоками.
        assertFalse(example.running, "Нить не была остановлена");
    }


    /**
     * <h4>Тест проверяет корректность обработки ошибок при операциях с банковскими счетами.</h4>
     *
     * <p>Цели теста:</p>
     * <ul>
     *     <li>Проверить, что при недостаточности средств на счете отправителя выбрасывается исключение {@link BalanceException}.</li>
     *     <li>Проверить, что при попытке перевести деньги на несуществующий счет получателя выбрасывается исключение
     *     {@link AccountNotFountByNumberException}.</li>
     *     <li>Проверить, что при попытке получить несуществующий аккаунт по ID выбрасывается исключение {@link AccountNotFountByIDException}.</li>
     *     <li>Проверить, что при попытке получить несуществующий аккаунт по номеру выбрасывается исключение
     *     {@link AccountNotFountByNumberException}.</li>
     * </ul>
     *
     * <p>В данном тесте:</p>
     * <ul>
     *     <li>Используется асинхронная операция перевода через {@link CompletableFuture}, которая выбрасывает исключения
     *     в случае ошибок.</li>
     *     <li>Все исключения обрабатываются через {@link CompletionException}, внутрь которой помещаются специфические исключения
     *     для каждой ситуации: {@link BalanceException}, {@link AccountNotFountByNumberException}, {@link AccountNotFountByIDException}.</li>
     *     <li>Для асинхронных операций ожидаем обертку {@link CompletionException}, так как исключения в асинхронных задачах передаются
     *     через этот класс.</li>
     * </ul>
     *
     * <h3>Описание тестов:</h3>
     * <ul>
     *     <li>Проверяется выбрасывание {@link BalanceException} при недостаточности средств на счете отправителя.</li>
     *     <li>Проверяется выбрасывание {@link AccountNotFountByNumberException} при попытке перевести деньги на несуществующий счет.</li>
     *     <li>Проверяется выбрасывание {@link AccountNotFountByIDException} при попытке получить несуществующий аккаунт по ID.</li>
     *     <li>Проверяется выбрасывание {@link AccountNotFountByNumberException} при попытке получить несуществующий аккаунт по номеру.</li>
     * </ul>
     *
     * <h3>Основные моменты:</h3>
     * <ul>
     *     <li>Тестирует, как {@link CompletableFuture} обрабатывает исключения при асинхронных операциях и как они обворачиваются в {@link CompletionException}.</li>
     *     <li>Проверяется корректность работы различных типов исключений, выбрасываемых в случае ошибок при работе с банковскими счетами.</li>
     *     <li>Каждое исключение проверяется на корректность его типа, с помощью {@link assertThrows} и проверкой причины исключения.</li>
     * </ul>
     */
    @Test
    public void ServiceExceptionTest() {

        // Проверка на выбрасывание BalanceException при недостаточности средств на счете отправителя
        CompletionException thrownBalanceException = assertThrows(CompletionException.class, () -> {
            // Запускаем асинхронный перевод с недостаточным балансом
            accountService.transferAsync("ACC3", "ACC1", new BigDecimal("100"))
                    .join(); // Ждем завершения задачи
        });

        // Проверяем, что внутри CompletionException находится BalanceException
        Throwable cause1 = thrownBalanceException.getCause();
        assertNotNull(cause1, "Cause of exception should not be null");
        assertInstanceOf(BalanceException.class, cause1, "Expected BalanceException but found: " + cause1.getClass().getName());

        // Проверка на выбрасывание AccountNotFountByNumberException при отсутствии счета получателя
        CompletionException thrownAccountNotFountByNumberException = assertThrows(CompletionException.class, () -> {
            // Запускаем асинхронный перевод с несуществующим счетом получателя
            accountService.transferAsync("ACC4", "ACC1", new BigDecimal("100"))
                    .join(); // Ждем завершения задачи
        });

        // Проверяем, что внутри CompletionException находится AccountNotFountByNumberException
        Throwable cause2 = thrownAccountNotFountByNumberException.getCause();
        assertNotNull(cause2, "Cause of exception should not be null");
        assertInstanceOf(AccountNotFountByNumberException.class, cause2, "Expected AccountNotFountByNumberException but found: " + cause2.getClass().getName());

        // Проверка на выбрасывание AccountNotFountByIDException при попытке получить несуществующий аккаунт по ID
        assertThrows(AccountNotFountByIDException.class, () -> {
            // Пробуем получить аккаунт с несуществующим ID
            accountService.getAccountById(1500L);
        });

        // Проверка на выбрасывание AccountNotFountByNumberException при попытке получить несуществующий аккаунт по номеру
        assertThrows(AccountNotFountByNumberException.class, () -> {
            // Пробуем получить аккаунт с несуществующим номером
            accountService.getAccountByNumber("125");
        });

    }


    /**
     * <h4>Тест демонстрирует использование обработчиков непойманных исключений в многозадачных потоках.</h4>
     *
     * <p>Цели теста:</p>
     * <ul>
     *     <li>Продемонстрировать, как можно обрабатывать непойманные исключения в потоках с использованием метода
     *     {@link Thread#setUncaughtExceptionHandler}.</li>
     *     <li>Показать, как исключения, возникающие в асинхронных операциях, могут быть правильно обработаны и
     *     зарегистрированы в логе.</li>
     * </ul>
     *
     * <p>В данном тесте:</p>
     * <ul>
     *     <li>Два потока выполняют асинхронные переводы денег через метод {@link AccountService#transferAsync}.</li>
     *     <li>Первый поток генерирует исключение из-за недостаточного баланса на счете.</li>
     *     <li>Второй поток генерирует исключение, пытаясь перевести деньги на несуществующий счет.</li>
     *     <li>Для каждого потока устанавливается обработчик непойманных исключений, который логирует ошибки.</li>
     * </ul>
     *
     * <p>Примечание: данный тест демонстрирует важность обработки исключений в многозадачных приложениях.</p>
     *
     * <h3>Описание:</h3>
     * <ul>
     *     <li>В первом потоке выполняется асинхронный перевод, который вызывает исключение из-за недостаточного баланса
     *     на счете. Исключение обрабатывается с помощью {@link try-catch} и логируется в консоль.</li>
     *     <li>Во втором потоке выполняется асинхронный перевод на несуществующий счет, что также приводит к исключению,
     *     которое обрабатывается и логируется.</li>
     *     <li>Для каждого потока устанавливается {@link Thread#setUncaughtExceptionHandler}, который позволяет перехватывать
     *     и логировать непойманные исключения, возникающие в потоках.</li>
     *     <li>После запуска потоков с помощью {@link Thread#start()}, основной поток продолжает выполнение и ждет завершения
     *     обоих потоков с помощью {@link Thread#join()}.</li>
     * </ul>
     *
     * <h3>Ключевые моменты:</h3>
     * <ul>
     *     <li>Использование {@link Thread#setUncaughtExceptionHandler} для регистрации обработчика непойманных исключений
     *     в потоках, что позволяет логировать ошибки, возникающие в фоновом режиме.</li>
     *     <li>Пример обработки исключений, связанных с асинхронными операциями, таких как недостаточный баланс или несуществующий
     *     счет.</li>
     *     <li>Показано, как можно продолжать выполнение основного потока, не блокируя его выполнение, при этом корректно обрабатывая
     *     исключения в дочерних потоках.</li>
     * </ul>
     */
    @Test
    public void testUncaughtExceptionHandlerInService() {
        // Создаем первый поток, который будет выполнять асинхронный перевод с недостаточным балансом
        Thread thread1 = new Thread(() -> {
            try {
                // Выполняем асинхронный перевод, который вызовет исключение из-за недостатка средств
                accountService.transferAsync("ACC3", "ACC1", new BigDecimal("100")).join();
            } catch (Exception e) {
                // Логируем исключение, если оно произошло в потоке
                System.err.println("Exception in thread " + Thread.currentThread().getName() + ": " + e.getMessage());
            }
        });

        // Создаем второй поток, который будет выполнять асинхронный перевод на несуществующий счет
        Thread thread2 = new Thread(() -> {
            try {
                // Выполняем асинхронный перевод, который вызовет исключение из-за несуществующего счета
                accountService.transferAsync("ACC4", "ACC1", new BigDecimal("100")).join();
            } catch (Exception e) {
                // Логируем исключение, если оно произошло в потоке
                System.err.println("Exception in thread " + Thread.currentThread().getName() + ": " + e.getMessage());
            }
        });

        // Устанавливаем обработчик непойманных исключений для первого потока
        thread1.setUncaughtExceptionHandler((t, e) -> {
            // Логируем информацию о непойманном исключении
            log.error("Uncaught exception in thread {}: {}", t.getName(), e.getMessage());
        });

        // Устанавливаем обработчик непойманных исключений для второго потока
        thread2.setUncaughtExceptionHandler((t, e) -> {
            // Логируем информацию о непойманном исключении
            log.error("Uncaught exception in thread {}: {}", t.getName(), e.getMessage());
        });

        // Запускаем первый поток
        thread1.start();
        // Запускаем второй поток
        thread2.start();

        // Печатаем сообщение, подтверждающее, что основной поток продолжает выполнение
        System.out.println("Основной поток продолжает выполнение...");

        // Ожидаем завершения первого потока, чтобы убедиться, что он завершится до конца теста
        try {
            thread1.join();
            // Ожидаем завершения второго потока
            thread2.join();
        } catch (InterruptedException e) {
            // Если основной поток был прерван, восстанавливаем состояние прерывания
            Thread.currentThread().interrupt();
        }
    }
}
